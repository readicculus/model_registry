

from sprokit.pipeline import process
from kwiver.kwiver_process import KwiverProcess

from vital.types import Image
from vital.types import ImageContainer
from vital.types import DetectedObject
from vital.types import DetectedObjectSet
from vital.types import BoundingBox, ObjectTrackSet, DetectedObjectType
import logging
logger = logging.getLogger(__name__)

def bb_contains_pt(bb, point):
    x,y = point
    return bb.min_x() <= x and bb.max_x() >= x and bb.min_y() <= y and  bb.max_y() >= y

class match_fixed_labels_with_detections(KwiverProcess):
    """
    This process gets an image as input, does some stuff to it and
    sends the modified version to the output port.
    """
    # ----------------------------------------------
    def __init__(self, conf):
        KwiverProcess.__init__(self, conf)

        # self.add_config_trait("match_iou",
        #   "match_iou",
        #   '.8',
        #   'IOU to declare two boxes matching')

        # self.declare_config_using_trait('match_iou')

        # set up required flags
        optional = process.PortFlags()
        required = process.PortFlags()
        required.add(self.flag_required)

        self.dos1_port_name = 'detected_object_set' + '1'
        self.dos2_port_name = 'detected_object_set' + '2'
        #  declare our input port (port-name,flags)
        self.add_port_trait(self.dos1_port_name, 'detected_object_set', 'Detections from camera1')
        self.add_port_trait(self.dos2_port_name, 'detected_object_set', 'Detections from camera2')
        self.declare_input_port_using_trait(self.dos1_port_name,  required)
        self.declare_input_port_using_trait(self.dos2_port_name, required)

        self.matches_port_name = 'detected_object_set' + '_matches'
        self.new_detections_port_name = 'detected_object_set' + '_new_detections'
        self.add_port_trait(self.matches_port_name, 'detected_object_set', 'Detections from camera3')
        self.add_port_trait(self.new_detections_port_name, 'detected_object_set', 'Detections from camera3')
        self.declare_output_port_using_trait(self.matches_port_name, optional)
        self.declare_output_port_using_trait(self.new_detections_port_name, optional)
        print(dir(self))
        print(self.input_ports())


    # ----------------------------------------------
    def _configure(self):
        # self.example_param = self.config_value('match_iou')

        self._base_configure()


    def match_point2box(self, detected_object_set1, detected_object_set2):
        points = []
        for d in detected_object_set1:
            bb = d.bounding_box()
            points.append(bb.center())

        box2pt_dict = {}
        for idx, d in enumerate(detected_object_set2):
            bb = d.bounding_box()
            cent = bb.center()
            box2pt_dict[idx] = []
            for pt_idx, pt in enumerate(points):
                if bb_contains_pt(bb, pt):
                    box2pt_dict[idx].append(pt_idx)


        pt2box_dict = {}
        for box_idx, pt_idxs in box2pt_dict.items():
            for pt_idx in pt_idxs:
                if pt_idx not in pt2box_dict:
                    pt2box_dict[pt_idx] = []
                pt2box_dict[pt_idx].append(box_idx)
        print(box2pt_dict)
        print(pt2box_dict)

        # unmatched detections (new)
        # unmatches points (not found)
        unmatched_detections = []
        for box_idx, pt_matches in box2pt_dict.items():
            if len(pt_matches) == 0:
                unmatched_detections.append(box_idx)

        unmatched_points = []
        for pt_idx, box_matches in pt2box_dict.items():
            if len(box_matches) == 0:
                unmatched_points.append(pt_idx)
                
        # matched detections (found, success)
        # multiple matches (todo: resolve matches)
        point_detection_matches = {} # pt_idx -> box_idx
        for pt_idx, box_matches in pt2box_dict.items():
            if len(box_matches) == 0:
                continue

            if len(box_matches) == 1:
                point_detection_matches[pt_idx] = box_matches[0]
            elif len(box_matches) > 1:
                # resolve conflict by highest confidence
                best_score = -1
                best_det = None
                for det_idx in box_matches:
                    det = detected_object_set2[det_idx]
                    if det.confidence() > best_score:
                        best_score = det.confidence()
                        best_det = det_idx

                point_detection_matches[pt_idx] = best_det
                
        matches = DetectedObjectSet()
        for pt_idx, det_idx in point_detection_matches.items():
            det = detected_object_set2[det_idx]
            pt = detected_object_set1[pt_idx]

            dettype = det.type()
            new_type = DetectedObjectType("matched_%s" % dettype.get_most_likely_class(), 1.)
            det.set_type(new_type)
            matches.add(det)


        new_detections = DetectedObjectSet()
        for det_idx in unmatched_detections:
            det = detected_object_set2[det_idx]
            dettype = det.type()
            new_type = DetectedObjectType("new_%s" % dettype.get_most_likely_class(), det.confidence())
            det.set_type(new_type)
            new_detections.add(det)
        return matches, new_detections


    # ----------------------------------------------
    def _step(self):
        # grab inputs
        detected_object_set1 = self.grab_input_using_trait(self.dos1_port_name)
        detected_object_set2 = self.grab_input_using_trait(self.dos2_port_name)

        # logger.debug("GT %d, Dets %d" % (len(detected_object_set1 ,detected_object_set2)))
        matches, new_detections = self.match_point2box(detected_object_set1, detected_object_set2)


        self.push_to_port_using_trait(self.matches_port_name, matches)
        self.push_to_port_using_trait(self.new_detections_port_name, new_detections)

        self._base_step()


